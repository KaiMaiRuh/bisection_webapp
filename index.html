<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bisection Method — เครื่องมือแบบอินเตอร์แอคทีฟ</title>
  <style>
    :root{--bg:#0f172a;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--glass:rgba(255,255,255,0.04)}
    *{box-sizing:border-box}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; margin:0; min-height:100vh; background:linear-gradient(180deg,#071129 0%, #071b2a 100%); color:#e6eef6}
    .wrap{max-width:1100px;margin:32px auto;padding:24px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px}
    header h1{font-size:20px;margin:0;color:var(--accent)}
    .grid{display:grid;grid-template-columns:360px 1fr;gap:20px;margin-top:18px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:16px; border-radius:12px}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input[type=text], input[type=number], select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:inherit}
    .row{display:flex;gap:12px}
    .row > *{flex:1}
    button.primary{background:linear-gradient(90deg,#06b6d4,#06a5d4);border:none;padding:10px 14px;border-radius:10px;color:#042027;font-weight:600;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:var(--muted);cursor:pointer}
    .result{margin-top:12px}
    .meta{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .meta div{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:8px;font-size:13px}
    canvas{width:100%;height:300px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:8px 6px;font-size:13px;text-align:right;border-bottom:1px dashed rgba(255,255,255,0.03)}
    th{background:rgba(255,255,255,0.02);text-align:right;color:var(--muted)}
    .footer{margin-top:18px;color:var(--muted);font-size:13px}
    @media (max-width:900px){.grid{grid-template-columns:1fr;}.card{padding:12px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Bisection Method — เครื่องมือช่วยคิดเชิงโต้ตอบ (ภาษไทย)</h1>
      <div style="font-size:13px;color:var(--muted)">แสดงผล: ตารางการทำงาน + กราฟ</div>
    </header>

    <div class="grid">
      <div class="card">
        <label for="expr">สมการ f(x) (ใช้ x เป็นตัวแปร, ฟังก์ชัน Math ใช้ชื่อปกติ เช่น sin, cos, exp, pow)</label>
        <input id="expr" type="text" value="x**3 - x - 2" placeholder="ตัวอย่าง: 45*x - 2 หรือ Math.sin(x) หรือ sin(x)" />

        <div style="height:10px"></div>
        <div class="row">
          <div>
            <label for="xl">ค่า XL (จุดซ้าย)</label>
            <input id="xl" type="number" step="any" value="1" />
          </div>
          <div>
            <label for="xr">ค่า XR (จุดขวา)</label>
            <input id="xr" type="number" step="any" value="2" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="row">
          <div>
            <label for="tol">Error (tolerance) | ตัวอย่าง: 1e-6</label>
            <input id="tol" type="text" value="1e-6" />
          </div>
          <div>
            <label for="maxIter">Max Iter</label>
            <input id="maxIter" type="number" value="50" />
          </div>
        </div>

        <div style="height:12px"></div>
        <div style="display:flex;gap:8px">
          <button class="primary" id="runBtn">คำนวณ</button>
          <button class="ghost" id="resetBtn">รีเซ็ต</button>
        </div>

        <div class="result">
          <div class="meta">
            <div id="status">สถานะ: ยังไม่ได้คำนวณ</div>
            <div id="iters">Iterations: -</div>
            <div id="root">root: -</div>
          </div>
        </div>

        <div style="margin-top:12px">
          <label>ตารางผลลัพธ์ (iteration)</label>
          <div style="overflow:auto;max-height:300px">
            <table id="table">
              <thead>
                <tr><th>iter</th><th>xl</th><th>xr</th><th>xm</th><th>f(xm)</th><th>error</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

      </div>

      <div>
        <div class="card">
          <label>กราฟฟังก์ชัน (ช่วงแสดงผล จะขยายจาก XL/XR เล็กน้อย)</label>
          <canvas id="plot" width="800" height="320"></canvas>
          <div class="footer">จุดสีเขียว = XL, สีแดง = XR, สีส้ม = XM(จุดกึ่งกลางสุดท้าย)</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // เรียกใช้ Math functions แบบไม่ต้องพิมพ์ Math. โดยใช้ with(Math)
    function makeFunc(expr){
      // แปลง ^ -> ** เพื่อให้ผู้ใช้พิมพ์ power แบบง่าย
      expr = expr.replace(/\^/g, '**');
      // ถ้าใช้ sin(x) ให้สามารถใช้ได้ (with Math)
      try{
        // new Function จะรับ x และคืนค่า
        return new Function('x', 'with(Math){ return (' + expr + '); }');
      }catch(e){
        return null;
      }
    }

    function bisection(func, a, b, tol, maxIter){
      let fa = func(a);
      let fb = func(b);
      if (!isFinite(fa) || !isFinite(fb)) return {error:'f(x) ไม่สามารถประเมินค่าได้ที่จุดเริ่มต้น'};
      if (fa * fb > 0) return {error:'f(a) และ f(b) ไม่มีเครื่องหมายตรงข้าม — อาจไม่มีรากหรือเลือกช่วงผิด'};

      let iterations = [];
      let xm = null;
      let prev_xm = null;
      for(let i=1;i<=maxIter;i++){
        xm = (a + b) / 2;
        let fxm = func(xm);
        let err = prev_xm === null ? null : Math.abs(xm - prev_xm);
        iterations.push({iter:i, xl:a, xr:b, xm:xm, fxm:fxm, error:err});
        if (!isFinite(fxm)) return {error:'f(xm) ไม่สามารถประเมินค่าได้ (เกิด NaN/Infinity)'};
        if (Math.abs(fxm) === 0 || (err !== null && err <= tol)){
          return {root:xm, iterations:iterations, converged:true};
        }
        if (fa * fxm < 0){
          b = xm; fb = fxm;
        } else {
          a = xm; fa = fxm;
        }
        prev_xm = xm;
      }
      return {root:xm, iterations:iterations, converged:false, message:'ถึงจำนวน iteration ที่กำหนด'};
    }

    function formatNum(x){
      if (x === null || x === undefined) return '-';
      if (!isFinite(x)) return String(x);
      if (Math.abs(x) < 1e-14) return '0';
      return Number(x).toPrecision(8).replace(/(?:\.0+$)|(?:(?<=\.[0-9]*[1-9])0+$)/,'');
    }

    // plot
    function drawPlot(canvas, func, xl, xr, lastXM){
      const ctx = canvas.getContext('2d');
      const W = canvas.width; const H = canvas.height;
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#061022'; ctx.fillRect(0,0,W,H);
      // sample xs across a bit wider range
      const pad = (xr - xl) * 0.2 || 1;
      const xmin = xl - pad; const xmax = xr + pad;
      const N = 800;
      let ys = []; let xs = [];
      let ymin=Infinity, ymax=-Infinity;
      for(let i=0;i<N;i++){
        const x = xmin + (xmax - xmin) * (i/(N-1));
        let y;
        try{ y = func(x); }catch(e){ y = NaN; }
        xs.push(x); ys.push(y);
        if(isFinite(y)){ if(y<ymin) ymin=y; if(y>ymax) ymax=y; }
      }
      if (ymin === Infinity) { ymin=-1; ymax=1; }
      // ensure some vertical padding
      const ypad = (ymax - ymin) * 0.2 || 1;
      ymin -= ypad; ymax += ypad;

      // helpers: map to canvas
      const mapX = x => ( (x - xmin) / (xmax - xmin) ) * W;
      const mapY = y => H - ( (y - ymin) / (ymax - ymin) ) * H;

      // axes
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth=1;
      // x-axis (y=0)
      if (ymin < 0 && ymax > 0){
        const y0 = mapY(0);
        ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(W,y0); ctx.stroke();
      }
      // y-axis (x=0)
      if (xmin < 0 && xmax > 0){
        const x0 = mapX(0);
        ctx.beginPath(); ctx.moveTo(x0,0); ctx.lineTo(x0,H); ctx.stroke();
      }

      // plot function line
      ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='#8ab4ff';
      let started=false;
      for(let i=0;i<N;i++){
        const x = xs[i]; const y = ys[i];
        if (!isFinite(y)) { started=false; continue; }
        const px = mapX(x); const py = mapY(y);
        if (!started) { ctx.moveTo(px,py); started=true; } else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // mark xl / xr / lastXM
      const drawMarker = (x, color, label) => {
        const px = mapX(x); if (px<0 || px>W) return;
        ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,H); ctx.strokeStyle=color; ctx.lineWidth=1.2; ctx.stroke();
        // dot
        ctx.beginPath(); ctx.arc(px, mapY( (ymin+ymax)/2 ), 4, 0, Math.PI*2); ctx.fillStyle=color; ctx.fill();
        // label
        ctx.fillStyle=color; ctx.font='12px Inter, Arial'; ctx.fillText(label + '='+formatNum(x), px+6, 18);
      };

      drawMarker(xl, '#22c55e', 'XL');
      drawMarker(xr, '#ef4444', 'XR');
      if (lastXM !== null) drawMarker(lastXM, '#fb923c', 'XM');
    }

    // UI wiring
    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const tableBody = document.querySelector('#table tbody');
    const status = document.getElementById('status');
    const itersBox = document.getElementById('iters');
    const rootBox = document.getElementById('root');
    const plotCanvas = document.getElementById('plot');

    runBtn.addEventListener('click', ()=>{
      const expr = document.getElementById('expr').value.trim();
      const xl = parseFloat(document.getElementById('xl').value);
      const xr = parseFloat(document.getElementById('xr').value);
      const tol = parseFloat(document.getElementById('tol').value);
      const maxIter = parseInt(document.getElementById('maxIter').value,10);
      if (isNaN(xl) || isNaN(xr)) { status.innerText='สถานะ: ค่า XL/XR ไม่ถูกต้อง'; return; }
      if (xl >= xr) { status.innerText='สถานะ: ต้องกำหนด XL < XR'; return; }
      const func = makeFunc(expr);
      if (!func){ status.innerText='สถานะ: สมการไม่ถูกต้อง'; return; }

      status.innerText='สถานะ: กำลังคำนวณ...';
      setTimeout(()=>{ // allow UI update
        const res = bisection(func, xl, xr, tol, maxIter);
        if (res.error){ status.innerText='สถานะ: ' + res.error; return; }
        // fill table
        tableBody.innerHTML='';
        res.iterations.forEach(row=>{
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${row.iter}</td><td>${formatNum(row.xl)}</td><td>${formatNum(row.xr)}</td><td>${formatNum(row.xm)}</td><td>${formatNum(row.fxm)}</td><td>${row.error===null?'-':formatNum(row.error)}</td>`;
          tableBody.appendChild(tr);
        });
        status.innerText = 'สถานะ: เสร็จสิ้น' + (res.converged? ' (converged)':' (ไม่ converged)');
        itersBox.innerText = 'Iterations: ' + res.iterations.length;
        rootBox.innerText = 'root: ' + formatNum(res.root);
        // draw plot with the last xm
        const lastXM = res.iterations.length ? res.iterations[res.iterations.length-1].xm : null;
        drawPlot(plotCanvas, func, xl, xr, lastXM);
      },50);
    });

    resetBtn.addEventListener('click', ()=>{
      document.getElementById('expr').value = 'x**3 - x - 2';
      document.getElementById('xl').value = '1';
      document.getElementById('xr').value = '2';
      document.getElementById('tol').value = '1e-6';
      document.getElementById('maxIter').value = '50';
      tableBody.innerHTML=''; status.innerText='สถานะ: รีเซ็ตแล้ว'; itersBox.innerText='Iterations: -'; rootBox.innerText='root: -';
      const func = makeFunc('x**3 - x - 2'); drawPlot(plotCanvas, func, 1, 2, null);
    });

    // initial draw
    window.addEventListener('load', ()=>{
      const func = makeFunc(document.getElementById('expr').value);
      drawPlot(plotCanvas, func, parseFloat(document.getElementById('xl').value), parseFloat(document.getElementById('xr').value), null);
    });

  </script>
</body>
</html>
